<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Coraz√≥n Relleno Grande</title>
  <style>
    body {
      margin: 0;
      background: linear-gradient(135deg, #5d26c1, #1a2980);
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      overflow: hidden;
      position: relative;
      padding: 20px 0;
    }

    #mensajeAmor {
      color: #fff;
      font-size: 1.0rem;
      font-family: 'Segoe UI', sans-serif;
      text-align: center;
      padding: 5px 20px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 15px;
      backdrop-filter: blur(6px);
      max-width: 95vw;
      white-space: pre-wrap;
      line-height: 1.8;
      word-spacing: 8px;
      box-shadow: 0 0 10px rgba(255, 255, 255, 0.3);
      margin-bottom: 20px;
      pointer-events: none;
    }

    canvas {
      background: transparent;
      display: block;
      width: 90vw;
      max-width: 700px;
      height: 300px;
    }

    #musicControl {
      margin-top: 2px;
      background: rgba(255, 255, 255, 0.2);
      border: none;
      color: white;
      font-size: 16px;
      padding: 10px 15px;
      border-radius: 10px;
      cursor: pointer;
      backdrop-filter: blur(5px);
      transition: background 0.3s;
    }

    #musicControl:hover {
      background: rgba(255, 255, 255, 0.3);
    }
  </style>
</head>
<body>

  <div id="mensajeAmor"></div>
  <canvas id="heartCanvas" width="700" height="600"></canvas>
  <button id="musicControl">üîä Reproducir m√∫sica</button>
  <audio id="bgMusic" src="audio/dondenadiepuedair.mp3" loop></audio>
  <audio id="bgMusic" src="audio/catorce.mp3" loop></audio>
  <script>
    const texto = `Mi amor es como este coraz√≥n jam√°s podr√° destruirse. Puede deformarse, pero nunca romperse. Y si alguien puede mejorarlo, eres t√∫. üíñ`;

    const mensaje = document.getElementById('mensajeAmor');
    let i = 0;
    function escribirMensaje() {
      if (i < texto.length) {
        mensaje.textContent += texto.charAt(i);
        i++;
        setTimeout(escribirMensaje, 40);
      }
    }
    setTimeout(() => {
      escribirMensaje();
    }, 500);

    const bgMusic = document.getElementById('bgMusic');
    const musicControl = document.getElementById('musicControl');

    musicControl.addEventListener('click', () => {
      if (bgMusic.paused) {
        bgMusic.play();
        musicControl.textContent = '‚è∏Ô∏è Pausar m√∫sica';
      } else {
        bgMusic.pause();
        musicControl.textContent = 'üîä Reproducir m√∫sica';
      }
    });

    const canvas = document.getElementById('heartCanvas');
    const ctx = canvas.getContext('2d');
    const width = canvas.width;
    const height = canvas.height;

    const PARTICLE_COUNT = 1200;
    const PARTICLE_SIZE = 9;

    let mouseX = null;
    let mouseY = null;

    let musicStarted = false;
    canvas.addEventListener('mousemove', () => {
      if (!musicStarted) {
        bgMusic.play().catch(() => {});
        musicControl.textContent = '‚è∏Ô∏è Pausar m√∫sica';
        musicStarted = true;
      }
    });

    canvas.addEventListener('mousemove', (e) => {
      const rect = canvas.getBoundingClientRect();
      mouseX = e.clientX - rect.left;
      mouseY = e.clientY - rect.top;
    });
    canvas.addEventListener('mouseleave', () => {
      mouseX = null;
      mouseY = null;
    });

    function isInsideHeart(x, y) {
      const scale = 180;
      const cx = (x - width / 2) / scale;
      const cy = (height / 2 - y) / scale;
      const val = Math.pow(cx * cx + cy * cy - 1, 3) - cx * cx * cy * cy * cy;
      return val <= 0;
    }

    const particles = [];
    while (particles.length < PARTICLE_COUNT) {
      const x = Math.random() * width;
      const y = Math.random() * height;
      if (isInsideHeart(x, y)) {
        particles.push({
          x: Math.random() * width,
          y: Math.random() * height,
          targetX: x,
          targetY: y,
          vx: 0,
          vy: 0,
          size: PARTICLE_SIZE,
          originalTargetX: x,
          originalTargetY: y
        });
      }
    }

    const SPRING = 0.08;
    const FRICTION = 0.85;
    const MOUSE_INFLUENCE = 190;
    const MOUSE_FORCE = 0.25;

    function updateParticle(p) {
      const dx = p.targetX - p.x;
      const dy = p.targetY - p.y;
      p.vx += dx * SPRING;
      p.vy += dy * SPRING;

      if (mouseX !== null && mouseY !== null) {
        const mdx = p.x - mouseX;
        const mdy = p.y - mouseY;
        const dist = Math.sqrt(mdx * mdx + mdy * mdy);
        if (dist < MOUSE_INFLUENCE) {
          const force = (MOUSE_INFLUENCE - dist) * MOUSE_FORCE;
          p.vx += (mdx / dist) * force;
          p.vy += (mdy / dist) * force;
        }
      }

      p.vx *= FRICTION;
      p.vy *= FRICTION;

      p.x += p.vx;
      p.y += p.vy;
    }

    function drawParticle(p) {
      ctx.beginPath();
      ctx.fillStyle = '#FF3366';
      ctx.shadowColor = 'rgba(255, 100, 150, 0.8)';
      ctx.shadowBlur = 8;
      ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
      ctx.fill();
    }

    const arrows = [];
    function spawnArrow() {
      const side = Math.random() > 0.1 ? 'left' : 'right';
      const x = side === 'left' ? 0 : width;
      const y = Math.random() * height;
      const angle = Math.atan2(height / 2 - y, width / 2 - x);
      arrows.push({ x, y, angle, speed: 3 });
      setTimeout(spawnArrow, 2000 + Math.random() * 3000);
    }
    spawnArrow();

    function drawArrow(arrow) {
      const len = 20;
      const headlen = 10;
      const endX = arrow.x + Math.cos(arrow.angle) * len;
      const endY = arrow.y + Math.sin(arrow.angle) * len;
      ctx.strokeStyle = '#ffffff';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(arrow.x, arrow.y);
      ctx.lineTo(endX, endY);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(endX, endY);
      ctx.lineTo(endX - headlen * Math.cos(arrow.angle - Math.PI / 6), endY - headlen * Math.sin(arrow.angle - Math.PI / 6));
      ctx.lineTo(endX - headlen * Math.cos(arrow.angle + Math.PI / 6), endY - headlen * Math.sin(arrow.angle + Math.PI / 6));
      ctx.closePath();
      ctx.fillStyle = '#ffffff';
      ctx.fill();
    }

    function animate() {
      ctx.clearRect(0, 0, width, height);

      for (const arrow of arrows) {
        arrow.x += Math.cos(arrow.angle) * arrow.speed;
        arrow.y += Math.sin(arrow.angle) * arrow.speed;
        drawArrow(arrow);

        if (isInsideHeart(arrow.x, arrow.y)) {
          for (let p of particles) {
            const dx = p.targetX - arrow.x;
            const dy = p.targetY - arrow.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist < 90) {
              p.targetX += (Math.random() - 0.5) * 50;
              p.targetY += (Math.random() - 0.5) * 50;
              setTimeout(() => {
                p.targetX = p.originalTargetX;
                p.targetY = p.originalTargetY;
              }, 1000);
            }
          }
        }
      }

      for (let p of particles) {
        updateParticle(p);
        drawParticle(p);
      }

      requestAnimationFrame(animate);
    }

    animate();
  </script>
</body>
</html>
